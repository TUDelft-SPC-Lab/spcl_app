#ifndef __SENDER_LIB_H
#define __SENDER_LIB_H

#include "sdk_errors.h"	// Needed for the definition of ret_code_t and the error-codes

/**< A structure that holds information about the received notification. */
typedef struct {
	uint16_t notification_len;
	uint64_t timepoint_ticks;
	uint32_t timepoint_seconds;
	uint16_t timepoint_milliseconds;
} receive_notification_t;


/**< The on receive notification callback function type. */
typedef void (*sender_receive_notification_handler_t) (receive_notification_t receive_notification);	



/**@brief Function to initialize the sender.
 *
 * @retval	NRF_SUCCESS				If initialization was successful.
 * @retval	NRF_ERROR_INTERNAL		If the FIFOs couldn't be initialized correctly.
 * @retval	NRF_ERROR_NO_MEM		If the disconnect timeout could not be registered.
 *
 * @note ble_init() has to be called before.
 * @note systick_init() has to be called before.
 * @note timeout_init() has to be called before.
 */
ret_code_t sender_init(void);


/**@brief Function set the notification handler, that should be called when a notification appears.
 *
 * @param[in] sender_receive_notification_handler	The handler that should be called when a notification appears.
 */
void sender_set_receive_notification_handler(sender_receive_notification_handler_t sender_receive_notification_handler);


/**@brief Function to retrieve the available bytes in the receive RX-FIFO.
 *
 * @retval	Number of available bytes in the receive RX-FIFO.
 */
uint32_t sender_get_received_data_size(void);

/**@brief Function to read bytes from the RX-FIFO.
 *
 * @param[out] 		data	Pointer where to store the read bytes.
 * @param[in/out] 	len		Pointer where the number of bytes to read is stored.
 *							If the specified number is larger than the number of bytes in RX-FIFO, 
 *							only the number of available bytes is read, and len is adapted.
 */
void sender_get_received_data(uint8_t* data, uint32_t* len);

/**@brief Function to read bytes from the RX-FIFO in blocking mode, with timeout.
 *
 * @param[out] 	data		Pointer where to store the read bytes.
 * @param[in] 	len			Number of bytes to read.
 * @param[in] 	timeout_ms	The timeout in milliseconds.
 *
 * @retval		NRF_SUCCESS					If len bytes have been read from the RX-FIFO.
 * @retval		NRF_ERROR_INVALID_STATE		If there is no alive BLE-connection.
 * @retval		NRF_ERROR_TIMEOUT			If a timeout occured.
 */
ret_code_t sender_await_data(uint8_t* data, uint32_t len, uint32_t timeout_ms);


/**@brief Function that returns the number of bytes in the transmit-FIFO.
 *
 * @retval		Number of bytes in the transmit-FIFO.
 */
uint32_t sender_get_transmit_fifo_size(void);

/**@brief Function to transmit bytes via the internal TX-FIFO.
 *
 * @details	If the data couldn't be put in the TX-FIFO in timeout_ms milliseconds,
 *			this function returns NRF_ERROR_NO_MEM.
 *			Internally, an app-timer is used to send the queued bytes in the FIFO.
 *			This timer periodically calls (every TRANSMIT_QUEUED_BYTES_PERIOD_MS) 
 *			the (20 byte) ble-transmitting function,
 *			to transmit the bytes (probably it would return that it couldn't send the
 *			bytes currently, but the timer holds with trying).
 *
 * @param[in] 	data		Pointer to data that should be sent.
 * @param[in] 	len			Number of bytes to read.
 * @param[in] 	timeout_ms	The timeout in milliseconds.
 *
 * @retval		NRF_SUCCESS					If len bytes have been read from the FIFO.
 * @retval		NRF_ERROR_INVALID_STATE		If there is no alive BLE-connection.
 * @retval		NRF_ERROR_NO_MEM			If a timeout occured.
 * @retval		Another error code generated by the ble-stack.
 */
ret_code_t sender_transmit(const uint8_t* data, uint32_t len, uint32_t timeout_ms);

/**@brief Function to disconnect from the current active connection.
 */
void sender_disconnect(void);


#endif 

